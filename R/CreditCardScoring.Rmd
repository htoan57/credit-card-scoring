---
title: "Credit Card Scoring"
author: "Tony Nguyen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#install.packages("dplyr")
#install.packages("readr")
#install.packages("ggplot2")
#install.packages("scorecard")
#install.packages("rpart.plot")
```

# Load linraries

```{r}
# Load packages
library(dplyr)
library(readr)
library(ggplot2)
library(scorecard)
library(rpart)
library(rpart.plot)
```

# Explore data

```{r}
# Load the Credit_Score.csv dataset
credit_df <- read.csv("Credit_Card.csv")

# Read the first few lines
head(credit_df)

# Understand the structure of Credit_Score csv
str(credit_df)
```

```{r}
# Explore the summary of Credit_Score.csv
summary(credit_df)
```
```{r}
# Check missing values for all columns
colSums(is.na(credit_df))
```

```{r}
# See rows where default.payment = 1 but PAY_ column < 0
filtered_default_1 <- credit_df[credit_df$default.payment == 1 & (
  credit_df$PAY_0 < 0 &
    credit_df$PAY_2 < 0 &
    credit_df$PAY_3 < 0 &
    credit_df$PAY_4 < 0 &
    credit_df$PAY_5 < 0 &
    credit_df$PAY_6 < 0
), ]

print(filtered_default_1)
```

```{r}
# See rows where default.payment = 0 but PAY_ column > 0
filtered_default_0 <- credit_df[credit_df$default.payment == 0 & (
  credit_df$PAY_0 > 0 &
    credit_df$PAY_2 > 0 &
    credit_df$PAY_3 > 0 &
    credit_df$PAY_4 > 0 &
    credit_df$PAY_5 > 0 &
    credit_df$PAY_6 > 0
), ]

print(filtered_default_0)
```


# Data cleaning and transformation

```{r}
# rename "pay_0" to "pay_1" to be consistent with BILL_AMT1 as PAY_0 is for September 2005
credit_df <- credit_df %>%
  rename("PAY_1" = "PAY_0")
```

```{r}
# Remove rows where Education or Marriage equals 0, these values are not defined in dataset
credit_df <- credit_df %>%
  filter(EDUCATION != 0, MARRIAGE != 0)

# Moreover, we combine "Unknown" values which are 5 and 6 to become 4 as Others value
credit_df$EDUCATION[credit_df$EDUCATION %in% c(5, 6)] <- 4
credit_df$EDUCATION <- as.integer(credit_df$EDUCATION)

# For PAY_1 to PAY_6, we combine values -2 and -1 into 0 as they are treated as less risk group
for (col in paste0("PAY_", 1:6)) {
  credit_df[[col]][credit_df[[col]] %in% c(-2, -1)] <- 0
  credit_df[[col]] <- as.integer(credit_df[[col]])
}
```

```{r}
# Recheck dataset after changing name and removing values
cat("Shape: ", dim(credit_df), "\n")
summary(credit_df)
sapply(credit_df, class)
```

# Explore demographic informaiton

```{r}
# Plot the linear regression between age and limit balance
ggplot(credit_df, aes(x = AGE, y = LIMIT_BAL)) +
  geom_smooth(
    method = "lm",
    se = TRUE,
    colour = "darkgreen",
    linewidth = 1.2
  ) +
  labs(title = "Linear Regression between Age and Credit Limit", x = "Age (years)", y = "Credit Limit (NT$)") +
  theme_minimal(base_size = 13)
```
```{r}
summary(lm(LIMIT_BAL ~ AGE, data = credit_df))
```


```{r}
# Count customers by Sex, Education, and Default
cust_no_by_Sex_Education_default <- credit_df %>%
  group_by(SEX, EDUCATION, default.payment) %>%
  summarise(count = n(), .groups = "drop")

# Stacked bars show Male vs Female customers using credit cards with default payment feature and different education levels
ggplot(cust_no_by_Sex_Education_default,
       aes(
         x = factor(EDUCATION),
         y = count,
         fill = factor(default.payment)
       )) +
  geom_bar(stat = "identity",
           position = "dodge",
           width = 0.7) +
  facet_wrap(~ SEX, labeller = labeller(SEX = c("1" = "Male", "2" = "Female"))) +
  geom_text(
    aes(label = count),
    position = position_dodge(width = 0.7),
    vjust = -0.4,
    size = 3
  ) +
  scale_x_discrete(labels = c(
    "1" = "Graduate School",
    "2" = "University",
    "3" = "High School",
    "4" = "Others"
  )) +
  scale_fill_manual(values = c("azure3", "red"),
                    labels = c("0" = "No", "1" = "Yes")) +
  labs(x = "Education Level",
       y = "Number of Customers",
       fill = "Default Payment",
       title = "Credit Card Defaults by Gender and Education Level") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1),
    strip.text = element_text(face = "bold", size = 11)
  )
```

```{r}
# Boxplots to show Limit balance among education levels
ggplot(credit_df, aes(
  x = factor(EDUCATION),
  y = LIMIT_BAL,
  fill = factor(SEX)
)) +
  geom_boxplot() +
  labs(title = "Credit Limit by Education level and Gender",
       x = "Education Level",
       y = "Credit Limit",
       fill = "Gender") +
  scale_x_discrete(labels = c(
    "1" = "Graduate School",
    "2" = "University",
    "3" = "High School",
    "4" = "Others"
  )) +
  scale_fill_manual(
    values = c("1" = "skyblue", "2" = "plum"),
    labels = c("1" = "Male", "2" = "Female")
  ) +
  theme_minimal()
```

```{r}
# Distribution of age by SEX using boxplots
ggplot(credit_df, aes(
  x = factor(EDUCATION),
  y = AGE,
  fill = factor(SEX)
)) +
  geom_boxplot(colour = "black") +
  scale_fill_manual(
    values = c("1" = "skyblue", "2" = "plum"),
    labels = c("1" = "Male", "2" = "Female")
  ) +
  scale_x_discrete(labels = c(
    "1" = "Graduate School",
    "2" = "University",
    "3" = "High School",
    "4" = "Others"
  )) +
  labs(title = "Age Distribution by Education Level and Gender",
       x = "Education Level",
       y = "Age",
       fill = "Gender") +
  theme_minimal()
```

# Create new variables that could impact on credit scores

```{r}
# Utilisation ratio is an important factor in credit scores
# We calculate average of all utilisation ratio of 6 months to understand the credit risk in each person
# The higher ratio, the risker since they are close to their financial limit

# Calculate utilisation ratio for each month
credit_df$util_1 <- credit_df$BILL_AMT1 / credit_df$LIMIT_BAL
credit_df$util_2 <- credit_df$BILL_AMT2 / credit_df$LIMIT_BAL
credit_df$util_3 <- credit_df$BILL_AMT3 / credit_df$LIMIT_BAL
credit_df$util_4 <- credit_df$BILL_AMT4 / credit_df$LIMIT_BAL
credit_df$util_5 <- credit_df$BILL_AMT5 / credit_df$LIMIT_BAL
credit_df$util_6 <- credit_df$BILL_AMT6 / credit_df$LIMIT_BAL

# There will be negative ratio since some customers pay more than the debt
# Replace these negative values into 0
credit_df$util_1[credit_df$util_1 < 0] <- 0
credit_df$util_2[credit_df$util_2 < 0] <- 0
credit_df$util_3[credit_df$util_3 < 0] <- 0
credit_df$util_4[credit_df$util_4 < 0] <- 0
credit_df$util_5[credit_df$util_5 < 0] <- 0
credit_df$util_6[credit_df$util_6 < 0] <- 0

# Calculate average of all 6-month ratios for each person
credit_df$avg_util_6month <- (
  credit_df$util_1 + credit_df$util_2 + credit_df$util_3 +
    credit_df$util_4 + credit_df$util_5 + credit_df$util_6
) / 6

# Check new created utilisation values
head(credit_df)
```

```{r}
# We also calculate average delay for each person based on payment status.
# The higher average value, the riskier of the person in using credits

# Calculate the average delay for 6 months
credit_df$avg_delay_6month <- (
  credit_df$PAY_1 + credit_df$PAY_2 + credit_df$PAY_3 +
    credit_df$PAY_4 + credit_df$PAY_5 + credit_df$PAY_6
) / 6
```

```{r}
# We're also interested in the maximum delay duration for each person
# Ex: a customer experienced the highest duration like 9 months across 6 months could be riskier than the one who has 2 months as the highest duration
credit_df$max_delay_6m <- pmax(
  credit_df$PAY_1,
  credit_df$PAY_2,
  credit_df$PAY_3,
  credit_df$PAY_4,
  credit_df$PAY_5,
  credit_df$PAY_6
)
```

```{r}
# The number of months for late payment are also indicators of risks in credits
# Ex: a customer with 8 months late across 6 months could be riskier than the one who has 3 months late across 6 months
credit_df$num_late_months <-
  (credit_df$PAY_1 > 0) +
  (credit_df$PAY_2 > 0) +
  (credit_df$PAY_3 > 0) +
  (credit_df$PAY_4 > 0) +
  (credit_df$PAY_5 > 0) +
  (credit_df$PAY_6 > 0)
```

```{r}
# Check new created varaibles
head(credit_df)
```


# Prepare Credit Scoring model and Credit Scorecard

```{r}
# ID column is normally excluded in analysis
credit_df_copy <- credit_df
credit_df_copy$ID <- NULL
```

```{r}
# Prepare data partition for training and testing, 70% for traning and 30% validation
credit_list <- split_df(
  credit_df_copy,
  y = "default.payment",
  ratios = c(0.7, 0.3),
  seed = 579
)
train <- credit_list$train
validation  <- credit_list$test
```

```{r}
# Perform binning
bins <- woebin(train,
               y = "default.payment",
               bins = 10,
               positive = "0")
bins
```

```{r}
# Create an empty IV table
iv_table <- data.frame(variable = character(), total_iv = numeric())

# Check IV value for each variable
for (value in names(bins)) {
  print(value)
  
  # get IV value for that variable
  iv_value <- bins[[value]]$total_iv[1]
  
  # add it to the table
  iv_table <- rbind(iv_table, data.frame(variable = value, total_iv = iv_value))
}

# Sort from highest to lowest
iv_table <- iv_table[order(-iv_table$total_iv), ]

# Print the table
print(iv_table)
```

```{r}
# Filter variables with total_iv >= 0.1 which are medium and strong variables
# There should be some demographic variables in a credit scorecard, age will be kept since it has the highest IV comparing to other demographic variables (SEX, MARRIAGE, EDUCATION)
selected_vars <- subset(iv_table, total_iv >= 0.1 | variable == "AGE")$variable
print(selected_vars)
```

```{r}
# We filter one more time, since "num_late_months", "avg_delay_6month" and "max_delay_6m" are calculated based on PAY_1 to PAY_6. We exclude PAY_1 to PAY_6 since on their own, these raw payment status are not directly meaningful for risk prediction. We exclude "PAY_AMT1", "PAY_AMT2" and "PAY_AMT3" with the same reason.
selected_vars_2 <- selected_vars[selected_vars %in% c("num_late_months",
                                                      "avg_delay_6month",
                                                      "max_delay_6m",
                                                      "LIMIT_BAL",
                                                      "AGE")]
print(selected_vars_2)
```

```{r}
# Loop through and plot each one to see if we need coarsing
for (value in selected_vars_2) {
  print(value)
  print(woebin_plot(bins[[value]]))
}
```


```{r}
# Keep only bins of selected variables
bins_selected <- bins[selected_vars_2]
bins_selected
```


```{r}
# Apply WoE binning once to both train and validation datasets
dt_woe_list <- lapply(list(train = train, validation = validation), function(x)
  woebin_ply(x, bins_selected))

# Extract results
train_woe <- as.data.frame(dt_woe_list$train)
validation_woe <- as.data.frame(dt_woe_list$validation)

# Create new variable names for WoE columns
woe_vars <- paste0(selected_vars_2, "_woe")

# Keep target and WoE variables only
train_woe <- train_woe[, c("default.payment", woe_vars), drop = FALSE]
validation_woe <- validation_woe[, c("default.payment", woe_vars), drop = FALSE]

# Check names
names(train_woe)
```

```{r}
# BUild logistic regression model
model <- glm(default.payment ~ ., family = binomial(), data = train_woe)
summary(model)
```

```{r}
# Check multicollinearity in initial model
vif(model, merge_coef = TRUE)
```

```{r}
# Some variables likely have multicollinearity, run stepwise AIC to automatically select best predictors
model_step <- step(model, direction = "both", trace = FALSE)
model_2 <- eval(model_step$call)
vif(model_2, merge_coef = TRUE)
```

```{r}
# We keep the model 2 and run logistic regression again
model_2 <- glm(
  default.payment ~ avg_delay_6month_woe + num_late_months_woe + LIMIT_BAL_woe + AGE_woe,
  family = binomial(),
  data = train_woe
)
summary(model_2)

```

```{r}
# Create probabilistic predictions using model_3
pred_list <- lapply(dt_woe_list, function(x)
  predict(model_2, newdata = x, type = "response"))

# Evaluate model performance with KS and ROC
label_list <- lapply(dt_woe_list, function(x)
  x$default.payment)

# Evaluate with perf_eva
perf_eva(pred_list, label_list, show_plot = "roc")
perf_eva(pred_list, label_list, show_plot = "ks")
perf_eva(pred_list, label_list, show_plot = "lift")
```

```{r}
# Create score card
card <- scorecard(
  bins = bins_selected,
  model = model_2,
  points0 = 600,
  odds0 = 1 / 30,
  pdo = 20
)

# View card
print(card)
```

```{r}
# Convert negative bins points to positive without changing the total scores
# Get original basepoint
original_basepoint <- card[["basepoints"]]$points

# Copy the scorecard
card_new <- card

# Get min value of avg_delay_6month and add all values based on this min
min1 <- min(card[["avg_delay_6month"]]$points)
if (min1 < 0) {
  card_new[["avg_delay_6month"]]$points <- card[["avg_delay_6month"]]$points + (-min1)
}

# Get min value of LIMIT_BAL and add all values based on this min
min2 <- min(card[["LIMIT_BAL"]]$points)
if (min2 < 0) {
  card_new[["LIMIT_BAL"]]$points <- card[["LIMIT_BAL"]]$points + (-min2)
}

# Get min value of AGE and add all values based on this min
min3 <- min(card[["AGE"]]$points)
if (min3 < 0) {
  card_new[["AGE"]]$points <- card[["AGE"]]$points + (-min3)
}

# Calculate total shift
total_shift <- sum(c(
  ifelse(min1 < 0, -min1, 0),
  ifelse(min2 < 0, -min2, 0),
  ifelse(min3 < 0, -min3, 0)
))

# Update to card_new (convert to data.frame to avoid empty result)
card_new[["basepoints"]]$points <- original_basepoint - total_shift
print(card_new)
```

```{r}
# Create an empty list to store only valid variable scorecards
valid_cards <- list()

# Loop through each item in card_new
for (item in card_new) {
  if (is.data.frame(item)) {
    valid_cards[[length(valid_cards) + 1]] <- item
  }
}

# Combine all variable scorecards into one table
card_df <- bind_rows(valid_cards)

# Count how many variables there are excluding basepoint
num_vars <- length(unique(card_df$variable[card_df$variable != "basepoints"]))

# Get the basepoints value
basepoints <- card_new[["basepoints"]]$points

# Divide basepoints evenly across all variables
bp_share <- basepoints / num_vars

# Add the shared basepoint to each bin's points
card_df$FinalPoints <- round(card_df$points + bp_share)

# Print the business scorecard
card_business <- card_df[card_df$variable != "basepoints", c("variable", "bin", "FinalPoints")]
print(card_business)
```


```{r}
# Check average score for default and not default
scores_all <- scorecard_ply(credit_df, card_new, print_step = 0)
avg_scores <- round(tapply(scores_all$score, credit_df$default.payment, mean), 0)
avg_scores
```

```{r}
# Choose the cutoff point
cutoff <- round(mean(avg_scores), 0)
cutoff
```


# Build prediction models

```{r}
# Build a decision tree with filtered variables from model 2
tree_model <- rpart(
  formula = default.payment ~ avg_delay_6month + num_late_months + LIMIT_BAL + AGE,
  data = train,
  method = "class"
)

# Print tree plot
rpart.plot(tree_model, main = "Decision Tree for Default Prediction")

# Predict probabilities on both datasets
tree_pred_train <- predict(tree_model, train, type = "prob")[, 2]
tree_pred_valid <- predict(tree_model, validation, type = "prob")[, 2]

# Create lists for perf_eva()
score_list <- list(train = tree_pred_train, validation = tree_pred_valid)
label_list <- list(train = train$default.payment,
                   validation = validation$default.payment)

# Evaluate performance for both train & validation
perf_eva(score_list, label_list, show_plot = "roc")
perf_eva(score_list, label_list, show_plot = "ks")
perf_eva(score_list, label_list, show_plot = "lift")
```

